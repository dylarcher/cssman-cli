// src/formatters/scssFormatter.js

import fs from 'fs/promises';
import path from 'path';

/**
 * Converts an InternalToken value to its SCSS string representation.
 * @param {*} value - The token's value.
 * @param {string} type - The token's DTCG type (e.g., "color", "number", "string", "dimension").
 * @returns {string} The SCSS string representation of the value.
 */
function formatScssValue(value, type) {
  switch (type) {
    case 'color':
      if (typeof value === 'object' && value !== null && 'r' in value && 'g' in value && 'b' in value) {
        // Assuming value is an {r, g, b, a} object (RGB 0-255, A 0-1)
        if (typeof value.a === 'number' && value.a < 1) {
          return `rgba(${value.r}, ${value.g}, ${value.b}, ${value.a})`;
        }
        // Convert to hex
        const rHex = value.r.toString(16).padStart(2, '0');
        const gHex = value.g.toString(16).padStart(2, '0');
        const bHex = value.b.toString(16).padStart(2, '0');
        return `#${rHex}${gHex}${bHex}`;
      }
      return String(value); // Fallback if it's already a string (e.g., from CSS)
    case 'string':
      // Ensure strings are quoted, escape existing quotes if necessary
      const escapedValue = String(value).replace(/'/g, "\\'");
      return `'${escapedValue}'`;
    case 'number':
    case 'dimension':
      return String(value); // SCSS handles units and numbers directly
    default:
      return String(value);
  }
}

/**
 * Builds a nested SCSS map string.
 * @param {object} mapObject - The object representing the map structure.
 * @param {number} indentLevel - Current indentation level.
 * @returns {string} SCSS map string.
 */
function buildScssMapString(mapObject, indentLevel = 0) {
    const indent = '  '.repeat(indentLevel);
    let scssString = '(\n';
    const keys = Object.keys(mapObject);

    keys.forEach((key, index) => {
        const value = mapObject[key];
        scssString += `${indent}  '${key}': `; // Quote map keys
        if (typeof value === 'object' && value !== null && !value.$isTokenValue) { // Check if it's a nested map
            scssString += buildScssMapString(value, indentLevel + 1);
        } else if (typeof value === 'object' && value !== null && value.$isTokenValue) { // It's a token leaf
            scssString += value.formattedValue;
        } else { // Should not happen if structure is correct
            scssString += `'${String(value).replace(/'/g, "\\'")}'`;
        }
        scssString += (index < keys.length - 1) ? ',\n' : '\n';
    });
    scssString += `${indent})`;
    return scssString;
}


/**
 * Formats an array of InternalToken objects into SCSS variable declarations and optionally a nested map.
 * @param {Array<InternalToken>} internalTokens - Array of InternalToken objects.
 * @param {object} options - Formatting options.
 * @param {boolean} [options.generateMap=false] - Whether to generate a single nested SCSS map.
 * @param {string} [options.mapName='tokens'] - The name of the SCSS map if generated.
 * @returns {string} The formatted SCSS content.
 */
function formatTokensToScss(internalTokens, options = {}) {
  let scssString = '// Generated by Tokman CLI - SCSS Variables\n\n';
  const { generateMap = false, mapName = 'tokens' } = options;

  if (generateMap) {
    const rootMap = {};
    internalTokens.forEach(token => {
      let currentLevel = rootMap;
      token.path.forEach((segment, index) => {
        if (index === token.path.length - 1) {
          currentLevel[segment] = {
            $isTokenValue: true, // Mark this as a direct token value
            formattedValue: formatScssValue(token.$value, token.$type)
          };
        } else {
          if (!currentLevel[segment] || typeof currentLevel[segment] !== 'object' || currentLevel[segment].$isTokenValue) {
            currentLevel[segment] = {};
          }
          currentLevel = currentLevel[segment];
        }
      });
    });
    scssString += `\$${mapName}: ${buildScssMapString(rootMap)};\n`;

  } else { // Generate individual variables
    internalTokens.forEach(token => {
      // Token names are typically like 'color-brand-primary'
      // SCSS variables are like $color-brand-primary
      const varName = `\$${token.name}`;
      const varValue = formatScssValue(token.$value, token.$type);
      if (token.$description) {
        scssString += `// ${token.$description}\n`;
      }
      scssString += `${varName}: ${varValue};\n\n`;
    });
  }
  return scssString;
}

/**
 * Writes the formatted SCSS tokens to a specified file.
 * @param {string} outputDir - The directory to write the file to.
 * @param {string} fileName - The name of the file (e.g., "_variables.scss").
 * @param {Array<InternalToken>} internalTokens - Array of InternalToken objects.
 * @param {object} options - Formatting options for formatTokensToScss.
 * @returns {Promise<void>}
 */
async function writeScssOutput(outputDir, fileName, internalTokens, options = {}) {
  if (!internalTokens) {
    throw new Error('No internal tokens provided to writeScssOutput.');
  }

  const scssContent = formatTokensToScss(internalTokens, options);
  const fullPath = path.join(outputDir, fileName);

  try {
    await fs.mkdir(outputDir, { recursive: true });
    await fs.writeFile(fullPath, scssContent, 'utf8');
    console.log(`Successfully wrote SCSS tokens to: ${fullPath}`);
  } catch (error) {
    console.error(`Error writing SCSS output to ${fullPath}:`, error);
    throw error;
  }
}

export {
  formatScssValue,
  formatTokensToScss,
  writeScssOutput,
};
