// src/formatters/cssFormatter.js

const fs = require('fs').promises;
const path = require('path');

/**
 * Converts an InternalToken value to its CSS string representation.
 * @param {*} value - The token's value.
 * @param {string} type - The token's DTCG type.
 * @returns {string} The CSS string representation of the value.
 */
function formatCssValue(value, type) {
  switch (type) {
    case 'color':
      if (typeof value === 'object' && value !== null && 'r' in value && 'g' in value && 'b' in value) {
        // Assuming value is an {r, g, b, a} object (RGB 0-255, A 0-1)
        if (typeof value.a === 'number' && value.a < 1) {
          return `rgba(${value.r}, ${value.g}, ${value.b}, ${value.a})`;
        }
        const rHex = value.r.toString(16).padStart(2, '0');
        const gHex = value.g.toString(16).padStart(2, '0');
        const bHex = value.b.toString(16).padStart(2, '0');
        return `#${rHex}${gHex}${bHex}`;
      }
      return String(value); // Fallback if it's already a string (e.g., from CSS source)
    case 'string':
      // CSS custom properties typically don't need extra quotes for strings unless the string itself contains spaces or special chars
      // and is not already quoted. For simplicity, we'll return the string as is.
      // If it needs to be a CSS <string> type for a standard property, it would need quotes.
      // For custom props, `var(--my-string)` would resolve to the raw string.
      return String(value);
    case 'number':
    case 'dimension':
      return String(value); // CSS handles units and numbers directly
    default:
      return String(value);
  }
}

/**
 * Formats an array of InternalToken objects into CSS Custom Property declarations.
 * @param {Array<InternalToken>} internalTokens - Array of InternalToken objects.
 * @param {object} options - Formatting options.
 * @param {string} [options.selector=':root'] - The CSS selector to scope the custom properties.
 * @returns {string} The formatted CSS content.
 */
function formatTokensToCss(internalTokens, options = {}) {
  const { selector = ':root' } = options;
  let cssString = '// Generated by Tokman CLI - CSS Custom Properties\n\n';
  cssString += `${selector} {\n`;

  internalTokens.forEach(token => {
    // Token names are typically like 'color-brand-primary'
    // CSS Custom Props are like --color-brand-primary
    const propName = `--${token.name}`;
    const propValue = formatCssValue(token.$value, token.$type);
    if (token.$description) {
      cssString += `  /* ${token.$description} */\n`;
    }
    cssString += `  ${propName}: ${propValue};\n`;
  });

  cssString += '}\n';
  return cssString;
}

/**
 * Writes the formatted CSS tokens to a specified file.
 * @param {string} outputDir - The directory to write the file to.
 * @param {string} fileName - The name of the file (e.g., "tokens.css").
 * @param {Array<InternalToken>} internalTokens - Array of InternalToken objects.
 * @param {object} options - Formatting options for formatTokensToCss.
 * @returns {Promise<void>}
 */
async function writeCssOutput(outputDir, fileName, internalTokens, options = {}) {
  if (!internalTokens) {
    throw new Error('No internal tokens provided to writeCssOutput.');
  }

  const cssContent = formatTokensToCss(internalTokens, options);
  const fullPath = path.join(outputDir, fileName);

  try {
    await fs.mkdir(outputDir, { recursive: true });
    await fs.writeFile(fullPath, cssContent, 'utf8');
    console.log(`Successfully wrote CSS tokens to: ${fullPath}`);
  } catch (error) {
    console.error(`Error writing CSS output to ${fullPath}:`, error);
    throw error;
  }
}

module.exports = {
  formatCssValue,
  formatTokensToCss,
  writeCssOutput,
};
